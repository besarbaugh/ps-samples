<#
.SYNOPSIS
    Loads exceptions from a specified JSON file.
.DESCRIPTION
    This function reads a JSON file from the specified file path and returns the deserialized content as a PowerShell object.
.PARAMETER FilePath
    The full path to the JSON file containing exceptions.
.EXAMPLE
    $exceptions = Get-Exceptions -FilePath "C:\exceptions.json"
.NOTES
    This function assumes the JSON file is properly formatted.
#>
function Get-Exceptions {
    param (
        [Parameter(Mandatory = $true)]
        [string]$FilePath
    )
    
    try {
        $content = Get-Content -Path $FilePath -Raw | ConvertFrom-Json
        return $content
    } catch {
        Write-Error "Failed to load exceptions from file: $_"
        return $null
    }
}


<#
.SYNOPSIS
    Saves the given list of exceptions to a JSON file.
.DESCRIPTION
    This function serializes the provided exceptions list to JSON and writes it to the specified file.
.PARAMETER ExceptionsList
    The list of exceptions to save, formatted as a hashtable.
.PARAMETER FilePath
    The full path to the file where the exceptions should be saved.
.EXAMPLE
    Save-Exceptions -ExceptionsList $exceptions -FilePath "C:\exceptions.json"
.NOTES
    The function overwrites the file if it already exists.
#>
function Save-Exceptions {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$ExceptionsList,
        
        [Parameter(Mandatory = $true)]
        [string]$FilePath
    )
    
    try {
        $ExceptionsList | ConvertTo-Json -Depth 10 | Set-Content -Path $FilePath
    } catch {
        Write-Error "Failed to save exceptions to file: $_"
    }
}


<#
.SYNOPSIS
    Validates an exception against a predefined schema.
.DESCRIPTION
    This function validates the provided exception against a JSON schema. Currently, it is a placeholder and always returns true.
.PARAMETER Exception
    The exception to validate, passed as a hashtable.
.EXAMPLE
    $isValid = Test-ExceptionSchema -Exception $exception
.NOTES
    The actual validation logic should be implemented here in the future.
#>
function Test-ExceptionSchema {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$Exception
    )

    # Placeholder for actual validation logic; returning true for now.
    return $true
}


<#
.SYNOPSIS
    Adds a new exception to the exceptions list and saves it to a file.
.DESCRIPTION
    This function creates a new exception object, validates it, checks for duplicates, and adds it to the list of exceptions if valid.
.PARAMETER SpnNamePatterns
    A hashtable containing patterns for SPN name matching.
.PARAMETER SPNDeptID
    The department ID associated with the SPN.
.PARAMETER ContainerTypes
    The types of containers (e.g., RG, Sub, MG) the SPN has access to.
.PARAMETER Roles
    The roles assigned to the SPN (e.g., owner, UAA, contributor).
.PARAMETER Environment
    The environment in which the SPN operates (e.g., Prod, QA).
.PARAMETER Dynamic
    Indicates whether the SPN is dynamic.
.PARAMETER DynamicScope
    Indicates whether dynamic scope applies.
.PARAMETER ExceptionType
    The type of exception (e.g., permanent, temporary).
.PARAMETER ISOApprovedID
    (Optional) The ISO-approved ID for permanent exceptions.
.PARAMETER TakeawayID
    (Optional) The ID for temporary exceptions that require cleanup.
.PARAMETER ExpirationDate
    (Optional) The expiration date for temporary exceptions.
.PARAMETER ContainerDeptID
    The department ID of the Azure container.
.PARAMETER ContainerID
    The ID of the Azure container (resource group, subscription, or management group).
.EXAMPLE
    Add-Exception -SpnNamePatterns $spnPatterns -SPNDeptID "Dept001" -ContainerTypes @("RG") -Roles @("owner") `
                   -Environment "Prod" -Dynamic $true -DynamicScope $false -ExceptionType "permanent" `
                   -ContainerDeptID "Dept001" -ContainerID "Container123"
.NOTES
    If a `TakeawayID` is provided, an `ExpirationDate` is required.
#>
function Add-Exception {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$SpnNamePatterns,

        [Parameter(Mandatory = $true)]
        [string]$SPNDeptID,

        [Parameter(Mandatory = $true)]
        [string[]]$ContainerTypes,

        [Parameter(Mandatory = $true)]
        [string[]]$Roles,

        [Parameter(Mandatory = $true)]
        [string]$Environment,

        [switch]$Dynamic = $false,

        [switch]$DynamicScope = $false,

        [Parameter(Mandatory = $true)]
        [string]$ExceptionType,

        [string]$ISOApprovedID,

        [string]$TakeawayID,

        [datetime]$ExpirationDate,

        [Parameter(Mandatory = $true)]
        [string]$ContainerDeptID,

        [Parameter(Mandatory = $true)]
        [string]$ContainerID
    )

    # Validate if TakeawayID requires ExpirationDate
    if ($TakeawayID -and -not $ExpirationDate) {
        Write-Error "TakeawayID requires an ExpirationDate."
        return
    }

    # Create the new exception object
    $newException = @{
        spnname_patterns     = $SpnNamePatterns
        spndeptid            = $SPNDeptID
        containertype        = $ContainerTypes
        role                 = $Roles
        environment          = $Environment
        dynamic              = $Dynamic
        dynamic_scope        = $DynamicScope
        exception_type       = $ExceptionType
        containerdeptid      = $ContainerDeptID
        containerid          = $ContainerID
    }

    # Add ISOApprovedID or TakeawayID if provided
    if ($ISOApprovedID) {
        $newException.ISOApprovedID = $ISOApprovedID
    } elseif ($TakeawayID) {
        $newException.TakeawayID = $TakeawayID
        $newException.expiration_date = $ExpirationDate
    }

    # Validate the new exception against the schema
    if (-not (Test-ExceptionSchema -Exception $newException)) {
        Write-Error "Validation failed. The exception could not be added."
        return
    }

    # Load the existing exceptions from the JSON file
    try {
        $exceptions = Get-Exceptions -FilePath $FilePath
    } catch {
        Write-Error "Failed to load the exceptions file: $_"
        return
    }

    # Check for duplicates
    $duplicate = $exceptions.Exceptions | Where-Object {
        $_.spnname_patterns.patterns -eq $SpnNamePatterns.patterns -and
        $_.containertype -eq $ContainerTypes -and
        $_.role -eq $Roles -and
        $_.environment -eq $Environment
    }

    if ($duplicate) {
        Write-Error "Duplicate exception found. No changes made."
        return
    }

    # Add the new exception to the list
    $exceptions.Exceptions += $newException

    # Save the updated exceptions list to the JSON file
    try {
        Save-Exceptions -ExceptionsList $exceptions -FilePath $FilePath
    } catch {
        Write-Error "Failed to save the updated exceptions file: $_"
        return
    }

    Write-Host "New exception added successfully."
}
