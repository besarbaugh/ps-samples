# Function: Test-ExceptionSchema
<#
.SYNOPSIS
    Validates an exception against the predefined schema.

.DESCRIPTION
    This function validates that the given exception adheres to the required schema, checking for required fields, 
    correct data types, and allowed values.

.PARAMETER Exception
    A hashtable representing the exception to validate.

.EXAMPLE
    PS C:\> Test-ExceptionSchema -Exception $newException

    Validates the $newException object against the schema.

.NOTES
    Returns $true if validation passes, $false otherwise.
#>
function Test-ExceptionSchema {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$Exception
    )

    $validationErrors = @()

    # Convert keys to lowercase to ensure case insensitivity
    $Exception = $Exception | ForEach-Object { $_.PSObject.Properties.Name = $_.PSObject.Properties.Name.ToLower(); $_ }

    # Required field check for SPNdeptID
    if (-not $Exception.ContainsKey("spndeptid")) {
        $validationErrors += "Missing required field: SPNdeptID (which maps to TakeAwayID and ISOApprovalID)."
    }

    # Required field check for other fields
    if (-not $Exception.ContainsKey("spnname_patterns")) {
        $validationErrors += "Missing required field: spnname_patterns."
    }
    if (-not $Exception.ContainsKey("containertype")) {
        $validationErrors += "Missing required field: containertype."
    }
    if (-not $Exception.ContainsKey("role")) {
        $validationErrors += "Missing required field: role."
    }
    if (-not $Exception.ContainsKey("environment")) {
        $validationErrors += "Missing required field: environment."
    }
    if (-not $Exception.ContainsKey("dynamic")) {
        $validationErrors += "Missing required field: dynamic."
    }
    if (-not $Exception.ContainsKey("dynamic_scope")) {
        $validationErrors += "Missing required field: dynamic_scope."
    }
    if (-not $Exception.ContainsKey("exception_type")) {
        $validationErrors += "Missing required field: exception_type."
    }

    # If TakeAwayID is present, expiration_date must be present
    if ($Exception.ContainsKey("takeawayid") -and -not $Exception.ContainsKey("expiration_date")) {
        $validationErrors += "TakeAwayID is present, but expiration_date is missing."
    }

    # Matching logic for SPNdeptID and AzureContainerDeptID
    if ($Exception.ContainsKey("spndeptid") -and $Exception.ContainsKey("azurecontainerdeptid")) {
        if ($Exception.spndeptid -ne $Exception.azurecontainerdeptid) {
            $validationErrors += "SPNdeptID does not match AzureContainerDeptID."
        }
    }

    # Enum validation for certain fields
    $validContainerTypes = @("rg", "sub", "mg")
    if ($Exception.containertype -and !($validContainerTypes -contains $Exception.containertype)) {
        $validationErrors += "Field containertype contains invalid values. Allowed values are 'RG', 'sub', 'MG'."
    }

    $validRoles = @("uaa", "owner", "contributor")
    if ($Exception.role -and !($validRoles -contains $Exception.role)) {
        $validationErrors += "Field role contains invalid values. Allowed values are 'UAA', 'owner', 'contributor'."
    }

    $validEnvironments = @("prod", "qa", "uat", "dev")
    if ($Exception.environment -and !($validEnvironments -contains $Exception.environment)) {
        $validationErrors += "Field environment contains invalid values. Allowed values are 'Prod', 'QA', 'UAT', 'Dev'."
    }

    # Return validation results
    if ($validationErrors.Count -eq 0) {
        Write-Host "Validation passed."
        return $true
    } else {
        Write-Host "Validation failed with errors:"
        $validationErrors | ForEach-Object { Write-Host $_ }
        return $false
    }
}

# Function: Add-Exception
<#
.SYNOPSIS
    Adds a new exception to the exceptions.json file in the root of the repo.

.DESCRIPTION
    This function validates a new exception and adds it to the specified exceptions.json file. It performs validation,
    duplicate checks, and saves the new exception to the file if it passes validation.

.EXAMPLE
    PS C:\> Add-Exception -SpnNamePatterns $spnNamePatterns -SPNDeptID "Dept001" -ContainerTypes @("RG", "sub") -Roles @("owner") -Environment "Prod" -Dynamic $true -DynamicScope $false -ExceptionType "dynamic" -ExpirationDate (Get-Date).AddMonths(6)

    Adds a new exception to the exceptions.json file after validation and duplicate checks.

.NOTES
    Ensure the JSON file is properly formatted and exists in the root directory.
#>
function Add-Exception {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$SpnNamePatterns,
        [Parameter(Mandatory = $true)]
        [string]$SPNDeptID,
        [Parameter(Mandatory = $true)]
        [array]$ContainerTypes,
        [Parameter(Mandatory = $true)]
        [array]$Roles,
        [Parameter(Mandatory = $true)]
        [string]$Environment,
        [Parameter(Mandatory = $true)]
        [bool]$Dynamic,
        [Parameter(Mandatory = $true)]
        [bool]$DynamicScope,
        [Parameter(Mandatory = $true)]
        [string]$ExceptionType,
        [datetime]$ExpirationDate = $null,
        [string]$AzureContainerDeptID = $null
    )

    try {
        # Path to exceptions.json
        $FilePath = Join-Path $PSScriptRoot "..\exceptions.json"

        # Build the new exception object
        $newException = @{
            spnname_patterns = $SpnNamePatterns
            spndeptid        = $SPNDeptID
            containertype    = $ContainerTypes
            role             = $Roles
            environment      = $Environment
            dynamic          = $Dynamic
            dynamic_scope    = $DynamicScope
            exception_type   = $ExceptionType
            expiration_date  = $ExpirationDate
            azurecontainerdeptid = $AzureContainerDeptID
        }

        # Convert all keys to lowercase
        $newException = $newException | ForEach-Object { $_.PSObject.Properties.Name = $_.PSObject.Properties.Name.ToLower(); $_ }

        # Validate the new exception against the schema
        if (-not (Test-ExceptionSchema -Exception $newException)) {
            Write-Error "Validation failed. The exception could not be added."
            return
        }

        # Load the existing exceptions from the JSON file
        try {
            $exceptions = Get-Exceptions
        } catch {
            Write-Error "Failed to load the exceptions file: $FilePath : $_"
            return
        }

        # Check for duplicates
        $duplicate = $exceptions.Exceptions | Where-Object {
            $_.spnname_patterns.patterns -eq $SpnNamePatterns.patterns -and
            $_.containertype -eq $ContainerTypes -and
            $_.role -eq $Roles -and
            $_.environment -eq $Environment
        }

        if ($duplicate) {
            Write-Error "Duplicate exception found. No changes made."
            return
        }

        # Add the new exception to the list
        $exceptions.Exceptions += $newException

        # Save the updated exceptions list to the JSON file
        try {
            Save-Exceptions -ExceptionsList $exceptions
        } catch {
            Write-Error "Failed to save the updated exceptions file: $FilePath : $_"
            return
        }

        Write-Host "New exception added successfully."
    } catch {
        Write-Error "An unexpected error occurred: $_"
    }
}

# Function: Save-Exceptions
<#
.SYNOPSIS
    Saves the updated exceptions list to the exceptions.json file in the root of the repo.

.DESCRIPTION
    This function takes a hashtable of exceptions and writes it to the specified exceptions.json file.

.EXAMPLE
    PS C:\> Save-Exceptions -ExceptionsList $exceptions

    Saves the exceptions list to the exceptions.json file.

.NOTES
    Ensure the file is accessible and writable before using this function.
#>
function Save-Exceptions {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$ExceptionsList
    )
    
    try {
        $FilePath = Join-Path $PSScriptRoot "..\exceptions.json"
        $jsonContent = $ExceptionsList | ConvertTo-Json -Depth 10
        $jsonContent | Out-File -FilePath $FilePath -Force
    } catch {
        Write-Error "Failed to save exceptions to $FilePath : $_"
    }
}

# Export module functions
Export-ModuleMember -Function Get-Exceptions, Test-ExceptionSchema, Add-Exception, Save-Exceptions
